'''
# 문제 이해
길이가 n인 배열 2개가 주어진다.
이 때 첫번째 배열의 순서를 바꾸어 서로 같은 자리의 배열을 서로 곱한 후 더한 최솟값을 출력한다.

# 발상
직관적으로 생각했을 때 그냥 배열 a는 가장 큰 수부터 차례대로, 배열 b는 가장 작은 수부터 차례대로 정렬한 후,
곱하고 더하면 될 것 같다.
'B에 있는 수는 재배열하면 안 된다.' 이 조건은 딱히 의미가 없어보인다.

# 복잡도
라이브러리 사용 빼고는 딱히 없을 듯
막상 풀어보니까 배열을 서로 더할 때 때문에 배열의 크기를 n이라고 했을 때 O(n)의 시간복잡도가 발생한다고 할 수 있다.

'''
n = int(input())

data = []

result = 0

for i in range(2):
    data.append(list(map(int, input().split())))

data[0].sort()
data[1].sort(reverse=True)

for j in range(n):
    result += data[0][j] * data[1][j]

print(result)


'''
# 푼 시간
13분

# 채점
정답

# 느낀 점
어렵지는 않았따.
다만 자꾸 파이참 내부 기능의 자동완성이 떠서 불편하기에 해제했다..

'''